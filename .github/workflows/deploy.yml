name: Deploy to VPS

on:
  workflow_run:
    workflows:
      - CI - Code Quality & Tests
    types:
      - completed
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'workflow_run' &&
        github.event.workflow_run.conclusion == 'success' &&
        github.event.workflow_run.head_branch == 'master'
      )
    permissions:
      contents: read
      actions: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: "recursive"

      - name: Prepare SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}

      - name: Add VPS to known hosts
        env:
          VPS_PORT: ${{ secrets.VPS_PORT }}
        run: |
          mkdir -p ~/.ssh
          VPS_PORT="${VPS_PORT:-22}"
          ssh-keyscan -p "${VPS_PORT}" -H "${{ secrets.VPS_HOST }}" >> ~/.ssh/known_hosts

      - name: Set branch and commit
        id: ref
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "BRANCH=${{ github.event.workflow_run.head_branch }}" >>$GITHUB_ENV
            echo "COMMIT_SHA=${{ github.event.workflow_run.head_sha }}" >>$GITHUB_ENV
          else
            echo "BRANCH=${GITHUB_REF_NAME}" >>$GITHUB_ENV
            echo "COMMIT_SHA=${{ github.sha }}" >>$GITHUB_ENV
          fi

      - name: Wait for CI success
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 - <<'PY'
          import json
          import os
          import sys
          import time
          import urllib.request
          
          repo = os.environ["GITHUB_REPOSITORY"]
          sha = os.environ.get("COMMIT_SHA") or os.environ["GITHUB_SHA"]
          token = os.environ.get("GITHUB_TOKEN")
          event_name = os.environ.get("GITHUB_EVENT_NAME", "")
          workflow_name = os.environ.get("CI_WORKFLOW_NAME", "CI - Code Quality & Tests")
          workflow_file = os.environ.get("CI_WORKFLOW_FILE", "ci.yml")
          max_attempts = 30
          sleep_seconds = 20
          
          base_headers = {
              "Authorization": f"Bearer {token}",
              "Accept": "application/vnd.github+json",
          }
          
          workflows_url = f"https://api.github.com/repos/{repo}/actions/workflows"
          workflows_req = urllib.request.Request(workflows_url, headers=base_headers)
          workflow_id = None
          with urllib.request.urlopen(workflows_req, timeout=20) as resp:
              data = json.loads(resp.read().decode("utf-8"))
          for wf in data.get("workflows", []):
              if wf.get("name") == workflow_name:
                  workflow_id = wf.get("id")
                  break
          workflow_ref = workflow_id or workflow_file
          
          url = f"https://api.github.com/repos/{repo}/actions/workflows/{workflow_ref}/runs?head_sha={sha}&per_page=1"
          req = urllib.request.Request(url, headers=base_headers)
          
          for attempt in range(1, max_attempts + 1):
              with urllib.request.urlopen(req, timeout=20) as resp:
                  data = json.loads(resp.read().decode("utf-8"))
          
              runs = data.get("workflow_runs", [])
              if not runs:
                  if event_name == "workflow_dispatch":
                      print("No CI runs found for this commit yet (manual deploy). Skipping wait.")
                      sys.exit(0)
                  print("No CI runs found for this commit yet.")
              else:
                  run = runs[0]
                  status = run.get("status")
                  conclusion = run.get("conclusion")
                  print(f"CI status={status}, conclusion={conclusion}")
                  if status == "completed":
                      if conclusion != "success":
                          print(f"CI run conclusion is {conclusion}. Aborting deploy.")
                          sys.exit(1)
                      print("CI succeeded, proceeding with deploy.")
                      sys.exit(0)
          
              if attempt < max_attempts:
                  time.sleep(sleep_seconds)
          
          print("CI did not complete in time. Aborting deploy.")
          sys.exit(1)
          PY

      - name: Deploy via SSH
        env:
          VPS_PORT: ${{ secrets.VPS_PORT }}
          VPS_PATH: ${{ secrets.VPS_PATH }}
          MAILCOW_HOSTNAME: ${{ secrets.MAILCOW_HOSTNAME }}
          MAILCOW_TZ: ${{ secrets.MAILCOW_TZ }}
          MAILCOW_ADMIN_EMAIL: ${{ secrets.MAILCOW_ADMIN_EMAIL }}
          MAILCOW_ADMIN_PASS: ${{ secrets.MAILCOW_ADMIN_PASS }}
          MAILCOW_API_KEY: ${{ secrets.MAILCOW_API_KEY }}
          MAILCOW_API_ALLOW_FROM: ${{ secrets.MAILCOW_API_ALLOW_FROM }}
          MAILCOW_DOMAIN: ${{ secrets.MAILCOW_DOMAIN }}
          MAILCOW_IMAP_MASTER_USER: ${{ secrets.MAILCOW_IMAP_MASTER_USER }}
          MAILCOW_IMAP_MASTER_PASS: ${{ secrets.MAILCOW_IMAP_MASTER_PASS }}
          MAILCOW_PROJECT_NAME: ${{ secrets.MAILCOW_PROJECT_NAME }}
          MAILCOW_ADDITIONAL_SERVER_NAMES: ${{ secrets.MAILCOW_ADDITIONAL_SERVER_NAMES }}
        run: |
          BRANCH="${BRANCH:-master}"
          COMMIT_SHA="${COMMIT_SHA:-$(git rev-parse HEAD)}"
          VPS_PORT="${VPS_PORT:-22}"
          ssh -p "${VPS_PORT}" \
            "${{ secrets.VPS_USER }}"@"${{ secrets.VPS_HOST }}" \
            VPS_PATH="${VPS_PATH}" \
            BRANCH="${BRANCH}" \
            COMMIT_SHA="${COMMIT_SHA}" \
            MAILCOW_HOSTNAME="${MAILCOW_HOSTNAME}" \
            MAILCOW_TZ="${MAILCOW_TZ}" \
            MAILCOW_ADMIN_EMAIL="${MAILCOW_ADMIN_EMAIL}" \
            MAILCOW_ADMIN_PASS="${MAILCOW_ADMIN_PASS}" \
            MAILCOW_API_KEY="${MAILCOW_API_KEY}" \
            MAILCOW_API_ALLOW_FROM="${MAILCOW_API_ALLOW_FROM}" \
            MAILCOW_DOMAIN="${MAILCOW_DOMAIN}" \
            MAILCOW_IMAP_MASTER_USER="${MAILCOW_IMAP_MASTER_USER}" \
            MAILCOW_IMAP_MASTER_PASS="${MAILCOW_IMAP_MASTER_PASS}" \
            MAILCOW_PROJECT_NAME="${MAILCOW_PROJECT_NAME}" \
            MAILCOW_ADDITIONAL_SERVER_NAMES="${MAILCOW_ADDITIONAL_SERVER_NAMES}" \
            bash -s <<'EOF'
          set -euo pipefail

          cd "${VPS_PATH}"

          echo "Fetching ${BRANCH}..."
          git fetch origin "${BRANCH}" --quiet

          # Ensure checkout cannot be blocked by local edits to tracked files
          # (untracked files like .env.production must remain untouched).
          git reset --hard --quiet
          git checkout "${COMMIT_SHA}"
          git submodule sync --recursive
          git submodule update --init --recursive

          if [ ! -f .env.production ]; then
            echo "Missing .env.production on server. Configure secrets via SSH before deploy."
            exit 1
          fi

          if [ -d mailcow ]; then
            echo "Preparing mailcow..."
            cd mailcow
            ln -sf mailcow.conf .env
            if [ ! -f mailcow.conf ]; then
              MAILCOW_HOSTNAME="${MAILCOW_HOSTNAME}" \
              MAILCOW_TZ="${MAILCOW_TZ}" \
              SKIP_CLAMD=y \
              ./generate_config.sh --dev
            fi

            python3 - <<'PY'
          import os
          import re
          from pathlib import Path

          path = Path("mailcow.conf")
          text = path.read_text(encoding="utf-8")

          def upsert(key: str, value: str) -> None:
              global text
              if f"{key}=" in text:
                  text = re.sub(rf"^{key}=.*$", f"{key}={value}", text, flags=re.MULTILINE)
              else:
                  text += f"\n{key}={value}\n"

          api_key = os.environ.get("MAILCOW_API_KEY", "")
          api_allow = os.environ.get("MAILCOW_API_ALLOW_FROM", "127.0.0.1,173.249.7.183")
          imap_master_user = os.environ.get("MAILCOW_IMAP_MASTER_USER", "crm_master")
          imap_master_pass = os.environ.get("MAILCOW_IMAP_MASTER_PASS", "crmMaster2026")
          project_name = os.environ.get("MAILCOW_PROJECT_NAME", "mailcow")
          additional_names = os.environ.get(
              "MAILCOW_ADDITIONAL_SERVER_NAMES",
              "autodiscover.zoom78.com,autoconfig.zoom78.com",
          )

          if api_key:
              upsert("API_KEY", api_key)
              upsert("API_ALLOW_FROM", api_allow)

          upsert("HTTP_BIND", "127.0.0.1")
          upsert("HTTP_PORT", "8080")
          upsert("HTTPS_BIND", "127.0.0.1")
          upsert("HTTPS_PORT", "8443")
          upsert("HTTP_REDIRECT", "n")
          upsert("SKIP_LETS_ENCRYPT", "y")
          upsert("DOVECOT_MASTER_USER", imap_master_user)
          upsert("DOVECOT_MASTER_PASS", imap_master_pass)
          upsert("COMPOSE_PROJECT_NAME", project_name)
          upsert("ADDITIONAL_SERVER_NAMES", additional_names)

          path.write_text(text, encoding="utf-8")
          PY
            cd ..

            if command -v ufw >/dev/null 2>&1; then
              ufw allow 25/tcp
              ufw allow 465/tcp
              ufw allow 587/tcp
              ufw allow 143/tcp
              ufw allow 993/tcp
              ufw allow 110/tcp
              ufw allow 995/tcp
              ufw allow 4190/tcp
            fi
          fi

          if [ -d mailcow ]; then
            echo "Starting mailcow stack"
            docker compose -f mailcow/docker-compose.yml up -d

            if [ -n "${MAILCOW_ADMIN_PASS}" ]; then
              echo "Ensuring mailcow admin password"
              cd mailcow
              # shellcheck disable=SC1091
              source mailcow.conf

              until [ -n "\$(docker compose -f docker-compose.yml ps -q mysql-mailcow)" ]; do sleep 3; done
              until [ -n "\$(docker compose -f docker-compose.yml ps -q dovecot-mailcow)" ]; do sleep 3; done

              password_hash=\$(docker compose -f docker-compose.yml exec -T dovecot-mailcow doveadm pw -s SSHA256 -p "${MAILCOW_ADMIN_PASS}" | tr -d '\r')
              docker compose -f docker-compose.yml exec -T mysql-mailcow \
                mysql -u\${DBUSER} -p\${DBPASS} \${DBNAME} -e "DELETE FROM admin WHERE username='admin';"
              docker compose -f docker-compose.yml exec -T mysql-mailcow \
                mysql -u\${DBUSER} -p\${DBPASS} \${DBNAME} -e "DELETE FROM domain_admins WHERE username='admin';"
              docker compose -f docker-compose.yml exec -T mysql-mailcow \
                mysql -u\${DBUSER} -p\${DBPASS} \${DBNAME} -e "INSERT INTO admin (username, password, superadmin, active) VALUES ('admin', '\${password_hash}', 1, 1);"
              docker compose -f docker-compose.yml exec -T mysql-mailcow \
                mysql -u\${DBUSER} -p\${DBPASS} \${DBNAME} -e "DELETE FROM tfa WHERE username='admin';"
              cd ..
            fi

            if [ -n "${MAILCOW_API_KEY}" ] && [ -n "${MAILCOW_DOMAIN}" ]; then
              echo "Ensuring mailcow domain exists"
              payload=$(printf '{"domain":"%s","description":"CRM domain","active":true,"aliases":200,"mailboxes":200,"maxquota":10240,"quota":10240,"defquota":3072,"restart_sogo":1}' "${MAILCOW_DOMAIN}")
              curl -s -X POST "http://127.0.0.1:8080/api/v1/add/domain" \
                -H "Content-Type: application/json" \
                -H "X-API-Key: ${MAILCOW_API_KEY}" \
                -d "${payload}" >/dev/null || true
            fi
          fi

          echo "Building and restarting stack"
          docker compose -f docker-compose.prod.yml --env-file .env.production up --build -d

          echo "Pruning unused images"
          docker image prune -f
          EOF
