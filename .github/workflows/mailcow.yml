name: Mailcow Redeploy

on:
  workflow_run:
    workflows:
      - Deploy to VPS
    types:
      - completed
  workflow_dispatch:

concurrency:
  group: vps-master
  cancel-in-progress: false

jobs:
  mailcow:
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'workflow_run' &&
        github.event.workflow_run.conclusion == 'success' &&
        github.event.workflow_run.head_branch == 'master'
      )
    steps:
      - name: Prepare SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}

      - name: Add VPS to known hosts
        env:
          VPS_PORT: ${{ secrets.VPS_PORT }}
        run: |
          mkdir -p ~/.ssh
          VPS_PORT="${VPS_PORT:-22}"
          ssh-keyscan -p "${VPS_PORT}" -H "${{ secrets.VPS_HOST }}" >> ~/.ssh/known_hosts

      - name: Set branch and commit
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "BRANCH=${{ github.event.workflow_run.head_branch }}" >>$GITHUB_ENV
            echo "COMMIT_SHA=${{ github.event.workflow_run.head_sha }}" >>$GITHUB_ENV
          else
            echo "BRANCH=${GITHUB_REF_NAME}" >>$GITHUB_ENV
            echo "COMMIT_SHA=${{ github.sha }}" >>$GITHUB_ENV
          fi

      - name: Redeploy Mailcow via SSH
        env:
          VPS_PORT: ${{ secrets.VPS_PORT }}
          VPS_PATH: ${{ secrets.VPS_PATH }}
          MAILCOW_HOSTNAME: ${{ secrets.MAILCOW_HOSTNAME }}
          MAILCOW_TZ: ${{ secrets.MAILCOW_TZ }}
          MAILCOW_ADMIN_EMAIL: ${{ secrets.MAILCOW_ADMIN_EMAIL }}
          MAILCOW_ADMIN_PASS: ${{ secrets.MAILCOW_ADMIN_PASS }}
          MAILCOW_API_KEY: ${{ secrets.MAILCOW_API_KEY }}
          MAILCOW_API_ALLOW_FROM: ${{ secrets.MAILCOW_API_ALLOW_FROM }}
          MAILCOW_DOMAIN: ${{ secrets.MAILCOW_DOMAIN }}
          MAILCOW_IMAP_MASTER_USER: ${{ secrets.MAILCOW_IMAP_MASTER_USER }}
          MAILCOW_IMAP_MASTER_PASS: ${{ secrets.MAILCOW_IMAP_MASTER_PASS }}
          MAILCOW_PROJECT_NAME: ${{ secrets.MAILCOW_PROJECT_NAME }}
          MAILCOW_ADDITIONAL_SERVER_NAMES: ${{ secrets.MAILCOW_ADDITIONAL_SERVER_NAMES }}
        run: |
          BRANCH="${BRANCH:-master}"
          COMMIT_SHA="${COMMIT_SHA:-${{ github.sha }}}"
          VPS_PORT="${VPS_PORT:-22}"
          ssh -p "${VPS_PORT}" \
            "${{ secrets.VPS_USER }}"@"${{ secrets.VPS_HOST }}" \
            VPS_PATH="${VPS_PATH}" \
            BRANCH="${BRANCH}" \
            COMMIT_SHA="${COMMIT_SHA}" \
            MAILCOW_HOSTNAME="${MAILCOW_HOSTNAME}" \
            MAILCOW_TZ="${MAILCOW_TZ}" \
            MAILCOW_ADMIN_EMAIL="${MAILCOW_ADMIN_EMAIL}" \
            MAILCOW_ADMIN_PASS="${MAILCOW_ADMIN_PASS}" \
            MAILCOW_API_KEY="${MAILCOW_API_KEY}" \
            MAILCOW_API_ALLOW_FROM="${MAILCOW_API_ALLOW_FROM}" \
            MAILCOW_DOMAIN="${MAILCOW_DOMAIN}" \
            MAILCOW_IMAP_MASTER_USER="${MAILCOW_IMAP_MASTER_USER}" \
            MAILCOW_IMAP_MASTER_PASS="${MAILCOW_IMAP_MASTER_PASS}" \
            MAILCOW_PROJECT_NAME="${MAILCOW_PROJECT_NAME}" \
            MAILCOW_ADDITIONAL_SERVER_NAMES="${MAILCOW_ADDITIONAL_SERVER_NAMES}" \
            bash -s <<'EOF'
          set -Eeuo pipefail

          on_error() {
            rc=$?
            cmd="${BASH_COMMAND%% *}"
            echo "ERROR: rc=${rc} line=${1} cmd=${cmd}"
            exit "${rc}"
          }
          trap 'on_error ${LINENO}' ERR
          trap 'rc=$?; echo "MARK: exit rc=${rc}"' EXIT

          echo "MARK: start mailcow"
          echo "MARK: VPS_PATH=${VPS_PATH} BRANCH=${BRANCH} COMMIT_SHA=${COMMIT_SHA}"

          cd "${VPS_PATH}"

          echo "Fetching ${BRANCH}..."
          git fetch origin "${BRANCH}" --quiet
          git reset --hard --quiet
          git checkout "${COMMIT_SHA}"
          git submodule sync --recursive
          git submodule update --init --recursive

          if [ ! -d mailcow ]; then
            echo "No mailcow/ directory in repo on server. Skipping."
            exit 0
          fi

          cd mailcow
          ln -sf mailcow.conf .env

          if [ ! -f mailcow.conf ]; then
            echo "MARK: generating mailcow.conf"
            MAILCOW_HOSTNAME="${MAILCOW_HOSTNAME}" \
            MAILCOW_TZ="${MAILCOW_TZ}" \
            SKIP_CLAMD=y \
            ./generate_config.sh --dev
          fi

          python3 - <<'PY'
          import os
          import re
          from pathlib import Path

          path = Path("mailcow.conf")
          text = path.read_text(encoding="utf-8")

          def upsert(key: str, value: str) -> None:
              global text
              if re.search(rf"^{re.escape(key)}=", text, flags=re.MULTILINE):
                  text = re.sub(
                      rf"^{re.escape(key)}=.*$",
                      f"{key}={value}",
                      text,
                      flags=re.MULTILINE,
                  )
              else:
                  text += f"\n{key}={value}\n"

          def normalize_allow_from(raw: str) -> str:
              parts = [p.strip() for p in re.split(r"[,\s;]+", raw or "") if p.strip()]
              required = ["127.0.0.1", "172.22.1.0/24"]
              for item in required:
                  if item not in parts:
                      parts.append(item)
              return ",".join(parts)

          api_key = os.environ.get("MAILCOW_API_KEY", "")
          api_allow = normalize_allow_from(
              os.environ.get(
              "MAILCOW_API_ALLOW_FROM",
              "127.0.0.1,173.249.7.183,172.22.1.0/24",
              )
          )
          imap_master_user = os.environ.get("MAILCOW_IMAP_MASTER_USER", "crm_master")
          imap_master_pass = os.environ.get("MAILCOW_IMAP_MASTER_PASS", "")
          project_name = os.environ.get("MAILCOW_PROJECT_NAME", "mailcow")
          additional_names = os.environ.get(
              "MAILCOW_ADDITIONAL_SERVER_NAMES",
              "autodiscover.zoom78.com,autoconfig.zoom78.com",
          )

          if api_key:
              upsert("API_KEY", api_key)
              upsert("API_ALLOW_FROM", api_allow)

          # Bind only locally. Public access should be via main nginx.
          upsert("HTTP_BIND", "127.0.0.1")
          upsert("HTTP_PORT", "8080")
          upsert("HTTPS_BIND", "127.0.0.1")
          upsert("HTTPS_PORT", "8443")
          upsert("HTTP_REDIRECT", "n")
          upsert("SKIP_LETS_ENCRYPT", "y")
          upsert("DOVECOT_MASTER_USER", imap_master_user)
          if imap_master_pass:
              upsert("DOVECOT_MASTER_PASS", imap_master_pass)
          upsert("COMPOSE_PROJECT_NAME", project_name)
          upsert("ADDITIONAL_SERVER_NAMES", additional_names)

          path.write_text(text, encoding="utf-8")
          PY

          if command -v ufw >/dev/null 2>&1; then
            ufw allow 25/tcp
            ufw allow 465/tcp
            ufw allow 587/tcp
            ufw allow 143/tcp
            ufw allow 993/tcp
            ufw allow 110/tcp
            ufw allow 995/tcp
            ufw allow 4190/tcp
          fi

          echo "MARK: docker compose up mailcow"
          docker compose -f docker-compose.yml up -d

          if [ -n "${MAILCOW_ADMIN_PASS}" ]; then
            echo "MARK: ensuring admin password"
            (
              set +e
              # shellcheck disable=SC1091
              source mailcow.conf

              until [ -n "$(docker compose -f docker-compose.yml ps -q mysql-mailcow)" ]; do sleep 3; done
              until [ -n "$(docker compose -f docker-compose.yml ps -q dovecot-mailcow)" ]; do sleep 3; done

              password_hash=$(docker compose -f docker-compose.yml exec -T dovecot-mailcow doveadm pw -s SSHA256 -p "${MAILCOW_ADMIN_PASS}" | tr -d '\r')
              docker compose -f docker-compose.yml exec -T mysql-mailcow \
                mysql -u${DBUSER} -p${DBPASS} ${DBNAME} -e "DELETE FROM admin WHERE username='admin';"
              docker compose -f docker-compose.yml exec -T mysql-mailcow \
                mysql -u${DBUSER} -p${DBPASS} ${DBNAME} -e "DELETE FROM domain_admins WHERE username='admin';"
              docker compose -f docker-compose.yml exec -T mysql-mailcow \
                mysql -u${DBUSER} -p${DBPASS} ${DBNAME} -e "INSERT INTO admin (username, password, superadmin, active) VALUES ('admin', '${password_hash}', 1, 1);"
              docker compose -f docker-compose.yml exec -T mysql-mailcow \
                mysql -u${DBUSER} -p${DBPASS} ${DBNAME} -e "DELETE FROM tfa WHERE username='admin';"
            ) || true
          fi

          if [ -n "${MAILCOW_API_KEY}" ] && [ -n "${MAILCOW_DOMAIN}" ]; then
            echo "MARK: ensuring domain exists"
            (
              set +e
              payload=$(printf '{"domain":"%s","description":"CRM domain","active":true,"aliases":200,"mailboxes":200,"maxquota":10240,"quota":10240,"defquota":3072,"restart_sogo":1}' "${MAILCOW_DOMAIN}")
              http_code=$(curl -s -o /dev/null -w "%{http_code}" -X POST "http://127.0.0.1:8080/api/v1/add/domain" \
                -H "Content-Type: application/json" \
                -H "X-API-Key: ${MAILCOW_API_KEY}" \
                -d "${payload}")
              rc=$?
              echo "MARK: ensure domain rc=${rc} http=${http_code}"
            ) || true
          fi

          echo "MARK: done mailcow"
          EOF
